"use server";

import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";

export interface ChatSessionWithMessages {
  id: string;
  phone: string;
  customerName: string | null;
  customerId: string | null;
  startedAt: Date;
  endedAt: Date | null;
  summary: string | null;
  category: string | null;
  status: string;
  isEscalated: boolean;
  escalatedAt: Date | null;
  escalateReason: string | null;
  priority: number;
  assignedToId: string | null;
  assignedAt: Date | null;
  customer: {
    name: string;
    email: string;
  } | null;
  assignedTo: {
    name: string | null;
    email: string;
  } | null;
  messages: {
    id: string;
    role: string;
    content: string;
    intent: string | null;
    isAutoGenerated: boolean;
    createdAt: Date;
  }[];
  _count: {
    messages: number;
  };
}

// 상담 세션 목록 조회
export async function getChatSessions(filters?: {
  status?: string;
  isEscalated?: boolean;
  category?: string;
  dateFrom?: Date;
  dateTo?: Date;
}) {
  try {
    const where: any = {};

    if (filters?.status) {
      where.status = filters.status;
    }
    if (filters?.isEscalated !== undefined) {
      where.isEscalated = filters.isEscalated;
    }
    if (filters?.category) {
      where.category = filters.category;
    }
    if (filters?.dateFrom || filters?.dateTo) {
      where.startedAt = {};
      if (filters.dateFrom) {
        where.startedAt.gte = filters.dateFrom;
      }
      if (filters.dateTo) {
        where.startedAt.lte = filters.dateTo;
      }
    }

    const sessions = await prisma.chatSession.findMany({
      where,
      include: {
        customer: {
          select: {
            name: true,
            email: true,
          },
        },
        assignedTo: {
          select: {
            name: true,
            email: true,
          },
        },
        _count: {
          select: {
            messages: true,
          },
        },
      },
      orderBy: {
        startedAt: 'desc',
      },
    });

    return sessions;
  } catch (error) {
    console.error("Failed to fetch chat sessions:", error);
    throw error;
  }
}

// 상담 세션 상세 조회
export async function getChatSessionById(id: string): Promise<ChatSessionWithMessages | null> {
  try {
    const session = await prisma.chatSession.findUnique({
      where: { id },
      include: {
        customer: {
          select: {
            name: true,
            email: true,
          },
        },
        assignedTo: {
          select: {
            name: true,
            email: true,
          },
        },
        messages: {
          orderBy: {
            createdAt: 'asc',
          },
        },
        _count: {
          select: {
            messages: true,
          },
        },
      },
    });

    return session;
  } catch (error) {
    console.error("Failed to fetch chat session:", error);
    throw error;
  }
}

// 상담 세션 통계
export async function getChatSessionStats() {
  try {
    const [total, active, closed, escalated] = await Promise.all([
      prisma.chatSession.count(),
      prisma.chatSession.count({ where: { status: 'ACTIVE' } }),
      prisma.chatSession.count({ where: { status: 'CLOSED' } }),
      prisma.chatSession.count({ where: { isEscalated: true } }),
    ]);

    // 채널별 통계
    const channelStats = await prisma.chatSession.groupBy({
      by: ['channel'],
      _count: {
        id: true,
      },
    });

    // 오늘 상담 건수
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayCount = await prisma.chatSession.count({
      where: {
        startedAt: {
          gte: today,
        },
      },
    });

    return {
      total,
      active,
      closed,
      escalated,
      todayCount,
      categoryStats: categoryStats.map((cat) => ({
        category: cat.category || '미분류',
        count: cat._count.id,
      })),
    };
  } catch (error) {
    console.error("Failed to fetch chat session stats:", error);
    return {
      total: 0,
      active: 0,
      closed: 0,
      escalated: 0,
      todayCount: 0,
      categoryStats: [],
    };
  }
}

// 상담 세션 상태 업데이트
export async function updateChatSessionStatus(id: string, status: string) {
  try {
    const data: any = { status };
    
    if (status === 'CLOSED') {
      data.endedAt = new Date();
    }

    await prisma.chatSession.update({
      where: { id },
      data,
    });

    revalidatePath('/dashboard/support/chat-history');
    return { success: true };
  } catch (error) {
    console.error("Failed to update chat session status:", error);
    return { success: false, error: String(error) };
  }
}

// 상담 요약 저장
export async function saveChatSessionSummary(id: string, summary: string, category?: string) {
  try {
    await prisma.chatSession.update({
      where: { id },
      data: {
        summary,
        category: category || undefined,
      },
    });

    revalidatePath('/dashboard/support/chat-history');
    return { success: true };
  } catch (error) {
    console.error("Failed to save chat session summary:", error);
    return { success: false, error: String(error) };
  }
}

// 상담 세션 삭제
export async function deleteChatSession(id: string) {
  try {
    // 먼저 메시지 삭제 (cascade 설정되어 있지만 명시적으로)
    await prisma.chatMessage.deleteMany({
      where: { sessionId: id },
    });

    await prisma.chatSession.delete({
      where: { id },
    });

    revalidatePath('/dashboard/support/chat-history');
    return { success: true };
  } catch (error) {
    console.error("Failed to delete chat session:", error);
    return { success: false, error: String(error) };
  }
}

// 상담 세션 내보내기용 데이터 가져오기
export async function getChatSessionsForExport() {
  try {
    const sessions = await prisma.chatSession.findMany({
      include: {
        customer: {
          select: {
            name: true,
            email: true,
          },
        },
        messages: {
          orderBy: {
            createdAt: 'asc',
          },
        },
      },
      orderBy: {
        startedAt: 'desc',
      },
    });

    return sessions.map((session) => ({
      id: session.id,
      phone: session.phone,
      customerName: session.customerName || session.customer?.name || '익명',
      customerEmail: session.customer?.email || '',
      status: session.status,
      category: session.category || '',
      summary: session.summary || '',
      isEscalated: session.isEscalated ? '예' : '아니오',
      escalateReason: session.escalateReason || '',
      startedAt: session.startedAt,
      endedAt: session.endedAt,
      messageCount: session.messages.length,
      conversation: session.messages
        .map((m) => `[${m.role}] ${m.content}`)
        .join('\n'),
    }));
  } catch (error) {
    console.error("Failed to fetch chat sessions for export:", error);
    throw error;
  }
}
